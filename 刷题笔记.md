

## 数据结构

## 数组相关题目
* 在处理数组和链表相关问题时，双指针技巧是经常用到的，双指针技巧主要分为两类：左右指针和快慢指针。只要数组有序，就应该想到双指针技巧
* 双指针的典型使用场景
  * 原地删除数组中的元素、翻转数组和字符串
  * nSum 的相关问题
  * 最长回文子字符串（指针从中间向两边进行扩散）
* 滑动窗口
* 滑动窗口模板代码
```text
/* 滑动窗口算法框架 */
void slidingWindow(string s, string t) {
    unordered_map<char, int> need, window;
    for (char c : t) need[c]++;
    
    int left = 0, right = 0;
    int valid = 0; 
    while (right < s.size()) {
        char c = s[right];
        // 右移（增大）窗口
        right++;
        // 进行窗口内数据的一系列更新

        while (window needs shrink) {
            char d = s[left];
            // 左移（缩小）窗口
            left++;
            // 进行窗口内数据的一系列更新
        }
    }
}
```


## 双指针
* 左右指针
* 快慢指针

### 左右指针的常用算法
26. 删除有序数组中的重复项（简单）
83. 删除排序链表中的重复元素（简单）
27. 移除元素（简单）
283. 移动零（简单）
167. 两数之和 II - 输入有序数组（中等）
344. 反转字符串（简单）
5. 最长回文子串（中等）



### 并查集
* Test547 省份数量（朋友圈数量 ）
* 




## 链表
### 单链表相关操作
* 基本就是双指针相关的操作
  * 1、合并两个有序链表
  * 2、合并 k 个有序链表
  * 3、寻找单链表的倒数第 k 个节点
  * 4、寻找单链表的中点
  * 5、判断单链表是否包含环并找出环起点
  * 6、判断两个单链表是否相交并找出交点
* LeetCode 题目练习 https://labuladong.gitee.io/algo/1/8/



## 查找
### 最基础
* 对于 有序数组 + 搜索 ： 使用二分法进行搜索


### 二分查找总结：
* T153 查找旋转数组的最小值（数组中的值各不相同）
* 


## 递归
* 写递归算法的关键是要明确函数的「定义」是什么，然后相信这个定义，利用这个定义推导最终结果，绝不要跳入递归的细节。
* 递归的典型应用场景是 二叉树 相关的算法
  * 写树相关的算法，简单说就是，先搞清楚当前 root 节点「该做什么」以及「什么时候做」，然后根据函数定义递归调用子节点，递归调用会让孩子节点做相同的事情
  * 所谓「该做什么」就是让你想清楚写什么代码能够实现题目想要的效果，所谓「什么时候做」，就是让你思考这段代码到底应该写在前序、中序还是后序遍历的代码位置上
* LeetCode 典型题目列举
  * T226 翻转二叉树 T114 将二叉树转换为链表


## 排序
### 最基础
* 熟练掌握快速排序、归并排序代码，各种排序算法的思想


### 应用场景
* 寻找乱序数组中第K大的元素(Test215)  ->  快速选择算法(基于快速排序中间的选择算法)
* 堆排序 -> 寻找第 K 大的元素
* 



## 搜索
### 深度优先搜索（DFS）
* 一般分成两部分，主函数和辅函数，主函数一般用来遍历所有的搜索位置，判断是否可以开始搜索，然后在辅函数中进行搜索。辅函数则进行深度优先搜索的递归调用。 
* 工程上一般是通过 栈 来完成，刷题时使用递归的方式就行。递归的方式可能会出现 栈 溢出的问题。
* LeetCode典型题目列举
  * TEST-547-朋友圈、省份圈


### 回溯法
* 优先搜索的一种特殊情况，又称为试探法，常用于需要记录节点状态的深度优先搜索。通常排列、组合、选择类问题使用回溯法比较方便。
* 算法步骤： 修改当前节点状态 -> 递归子节点 -> 回改当前节点状态
* 算法特点：不像动态规划那样存在重叠子问题可以优化，就是纯暴力穷举，复杂度一般都很高。
* 计算递归算法的时间复杂度：递归深度 * 每次递归迭代的的次数
* 本质就是遍历一颗多叉树，回溯算法的解题模板。需要记住子集（组合）和排列问题的回溯树。
```text
def backTrack(...)
    for 选择 in 选择列表：
        做选择
        backTrack(...)
        撤销选择
```


* 典型的工程题目：排列、组合、子集问题
78. 子集（中等）
90. 子集 II（中等）
77. 组合（中等）
39. 组合总和（中等）
40. 组合总和 II（中等）
216. 组合总和 III（中等）
46. 全排列（中等）
47. 全排列 II（中等）



### 广度优先搜索（BFS）
* 一般是用于处理最短路径问题，找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多。
* 通过 队列 的辅助数据结构进行实现，按照层次进行遍历
* 优化方式：双向BFS，从 start 和 end 两个边进行搜索，直到两个方向进行汇合。但是前提是要知道终点在哪里。
  * 本质是通过两个集合（SET即可，不需要使用队列），交换遍历的队列进行实现双向搜索
  * 无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，时间复杂度都是一样的
  * 只能说双向 BFS 是一种 trick，算法运行的速度会相对快一点
* LeetCode典型题目列举
  * T111-二叉树的最小深度  T752-解开密码的最少次数
  
```java
public class Demo {
  // 计算从起点 start 到终点 target 的最近距离
  int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
      int sz = q.size();
      /* 将当前队列中的所有节点向四周扩散 */
      for (int i = 0; i < sz; i++) {
        Node cur = q.poll();
        /* 划重点：这里判断是否到达终点 */
        if (cur is target)
        return step;
        /* 将 cur 的相邻节点加入队列 */
        for (Node x : cur.adj()) {
          if (x not in visited) {
            q.offer(x);
            visited.add(x);
          }
        }
      }
      /* 划重点：更新步数在这里 */
      step++;
    }
  }
}
```










## 动态规划
* 动态规划问题的一般形式就是求最值，其实是运筹学的一种最优化方法
* 求解动态规划的核心问题是穷举，三要素：重叠子问题、最优子结构、状态转移方程
  * 存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
  * 存在「最优子结构」，才能通过子问题的最值得到原问题的最值
  * 列出正确的「状态转移方程」
* 思维框架：base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义。 主要就是找出 状态 和 选择。
* 典型算法问题
  * 最长递增子序列、最小编辑距离



### 所有的股票买卖问题
* 主要是找出状态的变化，总结出状态变化方程，注意每个状态所指示的意义。
* [done] leetcode 工程问题
* 121. 买卖股票的最佳时机（简单）
* 122. 买卖股票的最佳时机 II（简单）
* 123. 买卖股票的最佳时机 III（困难）
* 124. 买卖股票的最佳时机 IV（困难）
* 125. 最佳买卖股票时机含冷冻期（中等）
* 126. 买卖股票的最佳时机含手续费（中等）


### 打家劫舍问题
全部都做
* 198. 打家劫舍（简单）
* 213. 打家劫舍II（中等）
* 337. 打家劫舍III（中等）






