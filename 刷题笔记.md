

## 数据结构

### 并查集
* Test547 省份数量（朋友圈数量 ）
* 




## 查找
### 最基础
* 对于 有序数组 + 搜索 ： 使用二分法进行搜索


### 二分查找总结：
* T153 查找旋转数组的最小值（数组中的值各不相同）
* 





## 排序
### 最基础
* 熟练掌握快速排序、归并排序代码，各种排序算法的思想


### 应用场景
* 寻找乱序数组中第K大的元素(Test215)  ->  快速选择算法(基于快速排序中间的选择算法)
* 堆排序 -> 寻找第 K 大的元素
* 



## 搜索
### 深度优先搜索（DFS）
* 一般分成两部分，主函数和辅函数，主函数一般用来遍历所有的搜索位置，判断是否可以开始搜索，然后在辅函数中进行搜索。辅函数则进行深度优先搜索的递归调用。 
* 工程上一般是通过 栈 来完成，刷题时使用递归的方式就行。递归的方式可能会出现 栈 溢出的问题。
* LeetCode典型题目列举
  * TEST-547-朋友圈、省份圈


* 回溯法
    * 优先搜索的一种特殊情况，又称为试探法，常用语需要记录节点状态的深度优先搜索。通常排列、组合、选择类问题使用回溯法比较方便。
    * 算法步骤： 修改当前节点状态 -> 递归子节点 -> 回改当前节点状态
    * 算法特点：不像动态规划那样存在重叠子问题可以优化，就是纯暴力穷举，复杂度一般都很高。
    * 计算递归算法的时间复杂度：递归深度 * 每次递归迭代的的次数
    * 本质就是遍历一颗多叉树
      回溯算法的解题模板

```text
def backTrack(...)
    for 选择 in 选择列表：
        做选择
        backTrack(...)
        撤销选择
```
### 广度优先搜索（BFS）
* 一般是用于处理最短路径问题，找到的路径一定是最短的，但代价就是空间复杂度可能比 DFS 大很多。
* 通过 队列 的辅助数据结构进行实现，按照层次进行遍历
* 优化方式：双向BFS，从 start 和 end 两个边进行搜索，直到两个方向进行汇合。但是前提是要知道终点在哪里。
  * 本质是通过两个集合（SET即可，不需要使用队列），交换遍历的队列进行实现双向搜索
  * 无论传统 BFS 还是双向 BFS，无论做不做优化，从 Big O 衡量标准来看，时间复杂度都是一样的
  * 只能说双向 BFS 是一种 trick，算法运行的速度会相对快一点
* LeetCode典型题目列举
  * T111-二叉树的最小深度  T752-解开密码的最少次数
  
```java
public class Demo {
  // 计算从起点 start 到终点 target 的最近距离
  int BFS(Node start, Node target) {
    Queue<Node> q; // 核心数据结构
    Set<Node> visited; // 避免走回头路

    q.offer(start); // 将起点加入队列
    visited.add(start);
    int step = 0; // 记录扩散的步数

    while (q not empty) {
      int sz = q.size();
      /* 将当前队列中的所有节点向四周扩散 */
      for (int i = 0; i < sz; i++) {
        Node cur = q.poll();
        /* 划重点：这里判断是否到达终点 */
        if (cur is target)
        return step;
        /* 将 cur 的相邻节点加入队列 */
        for (Node x : cur.adj()) {
          if (x not in visited) {
            q.offer(x);
            visited.add(x);
          }
        }
      }
      /* 划重点：更新步数在这里 */
      step++;
    }
  }
}
```










## 动态规划
* 动态规划问题的一般形式就是求最值，其实是运筹学的一种最优化方法
* 求解动态规划的核心问题是穷举，三要素：重叠子问题、最优子结构、状态转移方程
  * 存在「重叠子问题」，如果暴力穷举的话效率会极其低下，所以需要「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。
  * 存在「最优子结构」，才能通过子问题的最值得到原问题的最值
  * 列出正确的「状态转移方程」
* 思维框架：base case -> 明确「状态」-> 明确「选择」 -> 定义 dp 数组/函数的含义
* 典型算法问题
  * 最长递增子序列、最小编辑距离



